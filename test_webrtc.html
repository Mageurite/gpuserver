<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Avatar WebRTC æµ‹è¯•</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      color: #333;
      text-align: center;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    video {
      width: 100%;
      max-width: 512px;
      height: auto;
      border: 2px solid #ddd;
      border-radius: 8px;
      display: block;
      margin: 20px auto;
      background: black;
    }
    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin: 20px 0;
    }
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    .btn-primary {
      background: #007bff;
      color: white;
    }
    .btn-success {
      background: #28a745;
      color: white;
    }
    .btn-danger {
      background: #dc3545;
      color: white;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .status {
      padding: 15px;
      margin: 20px 0;
      border-radius: 5px;
      text-align: center;
      font-weight: bold;
    }
    .status.info {
      background: #d1ecf1;
      color: #0c5460;
    }
    .status.success {
      background: #d4edda;
      color: #155724;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
    }
    .log {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 5px;
      margin-top: 20px;
      max-height: 300px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
    }
    .log div {
      margin: 5px 0;
      padding: 5px;
      border-left: 3px solid #007bff;
      padding-left: 10px;
    }
    .input-group {
      margin: 20px 0;
    }
    .input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #555;
    }
    .input-group input {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ­ Avatar WebRTC å®æ—¶è§†é¢‘æµ‹è¯•</h1>
    
    <div class="input-group">
      <label>WebSocket URL:</label>
      <input type="text" id="wsUrl" value="ws://51.161.209.200:10110/ws/test-session">
    </div>

    <div class="input-group">
      <label>User ID:</label>
      <input type="number" id="userId" value="5">
    </div>

    <div class="input-group">
      <label>Tutor ID:</label>
      <input type="number" id="tutorId" value="13">
    </div>

    <video id="avatar-video" autoplay playsinline></video>

    <div class="controls">
      <button class="btn-primary" onclick="connectWebRTC()" id="btnConnect">
        ğŸ”— è¿æ¥ WebRTC
      </button>
      <button class="btn-success" onclick="sendMessage()" id="btnSend" disabled>
        ğŸ’¬ å‘é€æ¶ˆæ¯
      </button>
      <button class="btn-danger" onclick="disconnect()" id="btnDisconnect" disabled>
        âŒ æ–­å¼€è¿æ¥
      </button>
    </div>

    <div id="status" class="status info">ç­‰å¾…è¿æ¥...</div>

    <div class="log" id="log">
      <div>ğŸ“‹ æ—¥å¿—è¾“å‡ºï¼š</div>
    </div>
  </div>

  <script>
    let websocket;
    let peerConnection;
    let userId;
    let tutorId;
    let sessionId;

    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const timestamp = new Date().toLocaleTimeString();
      const div = document.createElement('div');
      div.textContent = `[${timestamp}] ${message}`;
      div.style.borderLeftColor = type === 'error' ? '#dc3545' : type === 'success' ? '#28a745' : '#007bff';
      logDiv.appendChild(div);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }

    function updateStatus(text, type = 'info') {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = text;
      statusDiv.className = `status ${type}`;
    }

    function updateButtons(wsConnected, webrtcConnected) {
      document.getElementById('btnConnect').disabled = wsConnected;
      document.getElementById('btnSend').disabled = !webrtcConnected;
      document.getElementById('btnDisconnect').disabled = !wsConnected;
    }

    // è¿æ¥ WebSocket
    function connectWebSocket() {
      return new Promise((resolve, reject) => {
        const wsUrl = document.getElementById('wsUrl').value;
        log(`æ­£åœ¨è¿æ¥ WebSocket: ${wsUrl}`);
        
        websocket = new WebSocket(wsUrl);
        
        websocket.onopen = () => {
          log('âœ… WebSocket è¿æ¥æˆåŠŸ', 'success');
          updateStatus('WebSocket å·²è¿æ¥', 'success');
          resolve();
        };

        websocket.onmessage = async (event) => {
          const message = JSON.parse(event.data);
          log(`ğŸ“¨ æ”¶åˆ°æ¶ˆæ¯: ${message.type}`);

          if (message.type === 'webrtc_answer') {
            // å¤„ç† WebRTC Answer
            log('å¤„ç† WebRTC Answer...');
            const answer = new RTCSessionDescription({
              type: 'answer',
              sdp: message.sdp
            });
            await peerConnection.setRemoteDescription(answer);
            log('âœ… WebRTC è¿æ¥å»ºç«‹æˆåŠŸ', 'success');
            updateStatus('WebRTC å·²è¿æ¥ï¼Œç­‰å¾…è§†é¢‘æµ...', 'success');
            updateButtons(true, true);
          } else if (message.type === 'text') {
            log(`ğŸ’¬ AI å“åº”: ${message.content.substring(0, 50)}...`);
          } else if (message.type === 'error') {
            log(`âŒ é”™è¯¯: ${message.content}`, 'error');
            updateStatus(`é”™è¯¯: ${message.content}`, 'error');
          }
        };

        websocket.onerror = (error) => {
          log('âŒ WebSocket é”™è¯¯', 'error');
          updateStatus('WebSocket é”™è¯¯', 'error');
          reject(error);
        };

        websocket.onclose = () => {
          log('WebSocket è¿æ¥å·²å…³é—­');
          updateStatus('è¿æ¥å·²æ–­å¼€', 'info');
          updateButtons(false, false);
        };
      });
    }

    // å»ºç«‹ WebRTC è¿æ¥
    async function connectWebRTC() {
      try {
        userId = parseInt(document.getElementById('userId').value);
        tutorId = parseInt(document.getElementById('tutorId').value);
        sessionId = 'test-session-' + Date.now();
        
        updateStatus('æ­£åœ¨è¿æ¥...', 'info');
        updateButtons(true, false);

        // è¿æ¥ WebSocket
        await connectWebSocket();

        log('åˆ›å»º RTCPeerConnection...');
        
        // åˆ›å»º RTCPeerConnectionï¼ˆSTUN + TURNï¼‰
        peerConnection = new RTCPeerConnection({
          iceServers: [
            // STUN: å‘ç°å…¬ç½‘IP
            { urls: 'stun:stun.l.google.com:19302' },
            // TURN: å½“P2På¤±è´¥æ—¶ä¸­ç»§
            {
              urls: 'turn:51.161.209.200:10110?transport=udp',
              username: 'vtuser',
              credential: 'vtpass'
            }
          ]
        });
        
        log('âœ… å·²é…ç½® STUN + TURN æœåŠ¡å™¨', 'success');

        // ç›‘å¬è¿œç¨‹è§†é¢‘æµ
        peerConnection.ontrack = (event) => {
          log('âœ… æ”¶åˆ°è¿œç¨‹è§†é¢‘æµ', 'success');
          const videoElement = document.getElementById('avatar-video');
          videoElement.srcObject = event.streams[0];
          videoElement.play().then(() => {
            log('âœ… è§†é¢‘å¼€å§‹æ’­æ”¾', 'success');
            updateStatus('æ­£åœ¨æ’­æ”¾è§†é¢‘', 'success');
          }).catch(err => {
            log('âŒ è§†é¢‘æ’­æ”¾å¤±è´¥: ' + err.message, 'error');
          });
        };

        // ç›‘å¬ ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            log('ğŸ“¤ å‘é€ ICE candidate');
            websocket.send(JSON.stringify({
              type: 'webrtc_ice_candidate',
              user_id: userId,
              candidate: event.candidate
            }));
          } else {
            log('ICE gathering å®Œæˆ');
          }
        };

        // ç›‘å¬è¿æ¥çŠ¶æ€
        peerConnection.onconnectionstatechange = () => {
          log(`WebRTC è¿æ¥çŠ¶æ€: ${peerConnection.connectionState}`);
          
          if (peerConnection.connectionState === 'connected') {
            updateStatus('WebRTC å·²è¿æ¥', 'success');
            // æ£€æŸ¥è¿æ¥ç±»å‹
            checkConnectionType();
          } else if (peerConnection.connectionState === 'failed') {
            updateStatus('WebRTC è¿æ¥å¤±è´¥', 'error');
            log('âŒ WebRTC è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œé…ç½®', 'error');
          }
        };

        // åˆ›å»º Offer
        log('åˆ›å»º WebRTC Offer...');
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        // å‘é€ Offer åˆ°æœåŠ¡å™¨
        log('ğŸ“¤ å‘é€ WebRTC Offer');
        websocket.send(JSON.stringify({
          type: 'webrtc_offer',
          session_id: sessionId,
          user_id: userId,
          avatar_id: 'avatar_tutor_13',
          sdp: offer.sdp
        }));

        log('ç­‰å¾…æœåŠ¡å™¨ Answer...');
        updateStatus('ç­‰å¾… WebRTC Answer...', 'info');

      } catch (error) {
        log('âŒ è¿æ¥å¤±è´¥: ' + error.message, 'error');
        updateStatus('è¿æ¥å¤±è´¥: ' + error.message, 'error');
        updateButtons(false, false);
      }
    }

    // æ£€æŸ¥è¿æ¥ç±»å‹ï¼ˆP2P æˆ–ä¸­ç»§ï¼‰
    async function checkConnectionType() {
      try {
        const stats = await peerConnection.getStats();
        stats.forEach(report => {
          if (report.type === 'candidate-pair' && report.state === 'succeeded') {
            log(`ğŸ“Š è¿æ¥ç±»å‹: ${report.localCandidateType || 'unknown'} -> ${report.remoteCandidateType || 'unknown'}`, 'success');
          }
        });
      } catch (error) {
        log('æ— æ³•è·å–è¿æ¥ç»Ÿè®¡ä¿¡æ¯', 'error');
      }
    }

    // å‘é€æ¶ˆæ¯è§¦å‘ AI å“åº”ï¼ˆå¸¦è§†é¢‘ï¼‰
    function sendMessage() {
      if (!websocket || websocket.readyState !== WebSocket.OPEN) {
        alert('è¯·å…ˆè¿æ¥ WebSocket');
        return;
      }

      const testMessages = [
        'ä½ å¥½ï¼Œè¯·ä»‹ç»ä¸€ä¸‹è‡ªå·±',
        'ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·ï¼Ÿ',
        'è¯·ç»™æˆ‘è®²ä¸ªç¬‘è¯',
        'ä½ èƒ½å¸®æˆ‘åšä»€ä¹ˆï¼Ÿ'
      ];
      
      const message = testMessages[Math.floor(Math.random() * testMessages.length)];

      log(`ğŸ“¤ å‘é€æ¶ˆæ¯: ${message}`);
      
      websocket.send(JSON.stringify({
        type: 'text_webrtc',  // ä½¿ç”¨ text_webrtc ç±»å‹è§¦å‘è§†é¢‘ç”Ÿæˆ
        session_id: sessionId,
        user_id: userId,
        tutor_id: tutorId,
        message: message,
        avatar_id: 'avatar_tutor_13'
      }));

      updateStatus('ç­‰å¾… AI å“åº”ï¼ˆçº¦5ç§’ï¼‰...', 'info');
    }

    // æ–­å¼€è¿æ¥
    function disconnect() {
      log('æ­£åœ¨æ–­å¼€è¿æ¥...');
      
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        log('WebRTC è¿æ¥å·²å…³é—­');
      }

      if (websocket) {
        websocket.close();
        websocket = null;
        log('WebSocket è¿æ¥å·²å…³é—­');
      }

      const videoElement = document.getElementById('avatar-video');
      videoElement.srcObject = null;

      updateStatus('å·²æ–­å¼€è¿æ¥', 'info');
      updateButtons(false, false);
    }

    // é¡µé¢å¸è½½æ—¶æ¸…ç†
    window.onbeforeunload = () => {
      disconnect();
    };

    log('é¡µé¢åŠ è½½å®Œæˆï¼Œç‚¹å‡»"è¿æ¥ WebRTC"å¼€å§‹æµ‹è¯•');
  </script>
</body>
</html>
